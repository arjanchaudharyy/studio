import { z } from 'zod';
import {
  componentRegistry,
  ConfigurationError,
  defineComponent,
  inputs,
  outputs,
  parameters,
  port,
  param,
} from '@shipsec/component-sdk';

const inputSchema = inputs({
  artifactName: port(
    z
      .string()
      .optional()
      .describe(
        'Name for the artifact. Supports dynamic placeholders: {{run_id}}, {{node_id}}, {{timestamp}}, {{date}}, {{time}}. Defaults to {{run_id}}-{{timestamp}}.',
      ),
    {
      label: 'Artifact Name',
      description:
        'Name for the artifact file. Use dynamic placeholders like {{run_id}}, {{timestamp}} for unique names.',
      editor: 'text',
    },
  ),
  content: port(
    z
      .any()
      .default('Generated by Artifact Writer component.')
      .describe(
        'Content that will be stored in the artifact. Can be text, JSON, arrays, or any serializable data.',
      ),
    {
      label: 'Content',
      description:
        'Content that will be stored inside the artifact. Accepts any data type - will be serialized to JSON if not already a string.',
      editor: 'textarea',
      allowAny: true,
      reason: 'Artifact writer can accept any serializable data type to be stored as a file.',
    },
  ),
});

/**
 * Substitutes dynamic placeholders in artifact name template.
 * Supported placeholders:
 * - {{run_id}} - Full workflow run ID
 * - {{node_id}} - Component's node ID in the workflow (e.g., "artifact-writer-1")
 * - {{timestamp}} - Unix timestamp in milliseconds
 * - {{date}} - ISO date (YYYY-MM-DD)
 * - {{time}} - ISO time (HH-MM-SS)
 */
function substituteArtifactName(
  template: string,
  context: { runId: string; componentRef: string },
): string {
  const now = new Date();
  const timestamp = now.getTime().toString();
  const isoDate = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const isoTime = now.toISOString().split('T')[1].split('.')[0].replace(/:/g, '-'); // HH-MM-SS

  return template
    .replace(/\{\{run_id\}\}/gi, context.runId)
    .replace(/\{\{node_id\}\}/gi, context.componentRef)
    .replace(/\{\{timestamp\}\}/gi, timestamp)
    .replace(/\{\{date\}\}/gi, isoDate)
    .replace(/\{\{time\}\}/gi, isoTime);
}

const parameterSchema = parameters({
  fileExtension: param(
    z.string().default('.txt').describe('File extension to append to the artifact name.'),
    {
      label: 'File Extension',
      editor: 'text',
      description:
        'File extension (e.g., .txt, .json, .csv). Will be appended to the artifact name.',
    },
  ),
  mimeType: param(
    z.string().default('text/plain').describe('Content MIME type. Defaults to text/plain.'),
    {
      label: 'MIME Type',
      editor: 'text',
      description: 'Content MIME type (e.g. text/plain, application/json).',
    },
  ),
  saveToRunArtifacts: param(
    z
      .boolean()
      .default(true)
      .describe('Store the artifact under the current run for quick inspection.'),
    {
      label: 'Save to Run Artifacts',
      editor: 'boolean',
      description: 'Keep a copy in the current run for quick inspection.',
    },
  ),
  publishToArtifactLibrary: param(
    z.boolean().default(false).describe('Also publish the artifact to the workspace-wide library.'),
    {
      label: 'Publish to Artifact Library',
      editor: 'boolean',
      description: 'Also publish to the workspace-level library for reuse.',
    },
  ),
});

const outputSchema = outputs({
  artifactId: port(z.string().optional(), {
    label: 'Artifact ID',
    description: 'Identifier returned by the artifact service.',
  }),
  artifactName: port(z.string(), {
    label: 'Artifact Name',
    description: 'Resolved name of the artifact (with placeholders substituted).',
  }),
  fileName: port(z.string(), {
    label: 'File Name',
    description: 'Full file name including extension.',
  }),
  size: port(z.number(), {
    label: 'Size',
    description: 'Size of the stored content in bytes.',
  }),
  destinations: port(z.array(z.enum(['run', 'library'])), {
    label: 'Destinations',
    description: 'Destination targets the artifact was stored in.',
  }),
  saved: port(z.boolean(), {
    label: 'Saved',
    description: 'Indicates whether the artifact was persisted.',
  }),
});

const definition = defineComponent({
  id: 'core.artifact.writer',
  label: 'Artifact Writer',
  category: 'output',
  runner: { kind: 'inline' },
  inputs: inputSchema,
  outputs: outputSchema,
  parameters: parameterSchema,
  docs: 'Writes any content (text, JSON, arrays, objects) to an artifact. Non-string content is automatically serialized to JSON. Useful for persisting workflow outputs, scan results, or any data.',
  ui: {
    slug: 'artifact-writer',
    version: '1.0.0',
    type: 'process',
    category: 'output',
    description:
      'Save any content (text, JSON, arrays, objects) as an artifact for the current run and/or the shared library.',
    icon: 'Archive',
    author: {
      name: 'ShipSecAI',
      type: 'shipsecai',
    },
  },
  async execute({ inputs, params }, context) {
    const destinations: ('run' | 'library')[] = [];
    if (params.saveToRunArtifacts) {
      destinations.push('run');
    }
    if (params.publishToArtifactLibrary) {
      destinations.push('library');
    }

    // Resolve artifact name with dynamic placeholders
    const artifactNameTemplate = inputs.artifactName || '{{run_id}}-{{timestamp}}';
    const resolvedArtifactName = substituteArtifactName(artifactNameTemplate, {
      runId: context.runId,
      componentRef: context.componentRef,
    });

    // Build full filename with extension
    const extension = params.fileExtension || '.txt';
    const fileName = resolvedArtifactName.endsWith(extension)
      ? resolvedArtifactName
      : `${resolvedArtifactName}${extension}`;

    // Serialize content to string - if already a string, use as-is; otherwise JSON stringify
    const rawContent = inputs.content;
    let serializedContent: string;
    if (rawContent === undefined || rawContent === null) {
      serializedContent = '';
    } else if (typeof rawContent === 'string') {
      serializedContent = rawContent;
    } else {
      // Serialize arrays, objects, and other types to JSON
      serializedContent = JSON.stringify(rawContent, null, 2);
    }

    if (destinations.length === 0) {
      context.logger.info('[ArtifactWriter] No destinations selected; skipping upload.');
      return {
        artifactId: undefined,
        artifactName: resolvedArtifactName,
        fileName,
        size: Buffer.byteLength(serializedContent),
        destinations: [],
        saved: false,
      };
    }

    if (!context.artifacts) {
      throw new ConfigurationError(
        'Artifact service is not available in this execution environment. Ensure the worker is configured with artifact storage.',
        { configKey: 'artifacts' },
      );
    }

    const buffer = Buffer.from(serializedContent, 'utf-8');
    context.logger.info(
      `[ArtifactWriter] Uploading '${fileName}' (${buffer.byteLength} bytes) to ${destinations.join(
        ', ',
      )}`,
    );

    const upload = await context.artifacts.upload({
      name: fileName,
      mimeType: params.mimeType ?? 'text/plain',
      content: buffer,
      destinations,
    });

    return {
      artifactId: upload.artifactId,
      artifactName: resolvedArtifactName,
      fileName,
      size: buffer.byteLength,
      destinations,
      saved: true,
    };
  },
});

componentRegistry.register(definition);

// Create local type aliases for backward compatibility
type Input = typeof inputSchema;
type Output = typeof outputSchema;

export type { Input as ArtifactWriterInput, Output as ArtifactWriterOutput };
