import { z } from 'zod';
import { componentRegistry, ComponentDefinition, ConfigurationError, withPortMeta } from '@shipsec/component-sdk';

const inputSchema = z.object({
  fileName: z
    .string()
    .min(1, 'File name is required')
    .default('artifact.txt')
    .describe('File name to assign to the saved artifact.'),
  content: withPortMeta(
    z.string()
      .default('Generated by Artifact Writer component.')
      .describe('Raw text that will be stored in the artifact.'),
    {
      label: 'Content',
      description: 'Text that will be stored inside the artifact.',
    },
  ),
  mimeType: z
    .string()
    .default('text/plain')
    .describe('Content MIME type. Defaults to text/plain.'),
  saveToRunArtifacts: z
    .boolean()
    .default(true)
    .describe('Store the artifact under the current run for quick inspection.'),
  publishToArtifactLibrary: z
    .boolean()
    .default(false)
    .describe('Also publish the artifact to the workspace-wide library.'),
});

type Input = z.infer<typeof inputSchema>;

const outputSchema = z.object({
  artifactId: withPortMeta(z.string().optional(), {
    label: 'Artifact ID',
    description: 'Identifier returned by the artifact service.',
  }),
  fileName: withPortMeta(z.string(), {
    label: 'File Name',
    description: 'Name of the artifact file that was written.',
  }),
  size: withPortMeta(z.number(), {
    label: 'Size',
    description: 'Size of the stored content in bytes.',
  }),
  destinations: withPortMeta(z.array(z.enum(['run', 'library'])), {
    label: 'Destinations',
    description: 'Destination targets the artifact was stored in.',
  }),
  saved: withPortMeta(z.boolean(), {
    label: 'Saved',
    description: 'Indicates whether the artifact was persisted.',
  }),
});

type Output = z.infer<typeof outputSchema>;

const definition: ComponentDefinition<Input, Output> = {
  id: 'core.artifact.writer',
  label: 'Artifact Writer',
  category: 'output',
  runner: { kind: 'inline' },
  inputs: inputSchema,
  outputs: outputSchema,
  docs:
    'Writes the provided text content to an artifact using the configured file name and destinations. Useful for testing the artifact pipeline or persisting lightweight diagnostics.',
  ui: {
    slug: 'artifact-writer',
    version: '1.0.0',
    type: 'process',
    category: 'output',
    description: 'Save arbitrary text content as an artifact for the current run and/or the shared library.',
    icon: 'Archive',
    author: {
      name: 'ShipSecAI',
      type: 'shipsecai',
    },
    parameters: [
      {
        id: 'fileName',
        label: 'File Name',
        type: 'text',
        required: false,
        default: 'artifact.txt',
        description: 'File name to use when saving the artifact.',
      },
      {
        id: 'mimeType',
        label: 'MIME Type',
        type: 'text',
        required: false,
        default: 'text/plain',
        description: 'Content MIME type (e.g. text/plain, application/json).',
      },
      {
        id: 'content',
        label: 'Content',
        type: 'textarea',
        default: 'Generated by Artifact Writer component.',
        description: 'Raw text content that will be written to the artifact.',
      },
      {
        id: 'saveToRunArtifacts',
        label: 'Save to Run Artifacts',
        type: 'boolean',
        default: true,
        description: 'Keep a copy in the current run for quick inspection.',
      },
      {
        id: 'publishToArtifactLibrary',
        label: 'Publish to Artifact Library',
        type: 'boolean',
        default: false,
        description: 'Also publish to the workspace-level library for reuse.',
      },
    ],
  },
  async execute(params, context) {
    const destinations: Array<'run' | 'library'> = [];
    if (params.saveToRunArtifacts) {
      destinations.push('run');
    }
    if (params.publishToArtifactLibrary) {
      destinations.push('library');
    }

    if (destinations.length === 0) {
      context.logger.info('[ArtifactWriter] No destinations selected; skipping upload.');
      return {
        artifactId: undefined,
        fileName: params.fileName,
        size: Buffer.byteLength(params.content ?? ''),
        destinations: [],
        saved: false,
      };
    }

    if (!context.artifacts) {
      throw new ConfigurationError(
        'Artifact service is not available in this execution environment. Ensure the worker is configured with artifact storage.',
        { configKey: 'artifacts' },
      );
    }

    const buffer = Buffer.from(params.content ?? '', 'utf-8');
    context.logger.info(
      `[ArtifactWriter] Uploading '${params.fileName}' (${buffer.byteLength} bytes) to ${destinations.join(
        ', ',
      )}`,
    );

    const upload = await context.artifacts.upload({
      name: params.fileName,
      mimeType: params.mimeType ?? 'text/plain',
      content: buffer,
      destinations,
    });

    return {
      artifactId: upload.artifactId,
      fileName: params.fileName,
      size: buffer.byteLength,
      destinations,
      saved: true,
    };
  },
};

componentRegistry.register(definition);

export type { Input as ArtifactWriterInput, Output as ArtifactWriterOutput };
